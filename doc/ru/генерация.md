# Генерация кода

Генерация кода осуществляется одновременно с разбором
синтаксиса и семантическим анализом.

Код языка Pascal переводится в текстовое представление WebAssembly,
которое затем трансформируется в двоичное представление
с помощью библиотеки [wat](https://crates.io/crates/wat).

Генерация кода поддерживает 32-битные целочисленные и вещественные типы,
а также скалярные типы данных (которые представляются целыми числами).
Компилятор может генерировать код для операторов присваивания, `if`, `while`,
`repeat` и `for`.


Генерация отдельных команд WebAssembly выделена в
[отдельный модуль](../../src/translation).

## Текстовый формат Wasm

WebAssembly имеет два представления: бинарное и текстовое.
Текстовое представление является человеко-читаемым,
его основой являются S-выражения.

### Синтаксис

Самая простая программа, представленная в текстовом формате Wasm,
имеет следующий вид:

```
(module)
```

WebAssembly модуль представляет бинарный файл, скомпилированный
окружением в исполняемый машинный код.

Модуль может хранить функции и данные. Функцию в текстовом представлении
можно описать следующим образом:

```
(module
  (func (param i32) (param $a i32) (local $b i32) (result f64))
)
```

Ключевому слову `param` соответствует аргумент функции, `local` --
локальная переменная, `result` -- выходное значение функции.
На данный момент Wasm поддерживает 4 числовых типа:
 - i32: 32-битный целочисленный тип,
 - i64: 64-битный целочисленный тип,
 - f32: 32-битный тип с плавающей точкой,
 - f64: 64-битный тип с плавающей точкой.

По умолчанию параметры и локальные переменные нумеруются, начиная
с нуля в порядке их указания в сигнатуре функции. Таким образом
в примере выше первый `param` будет иметь номер 0, второй -- номер 1,
а `local` будет иметь номер 2.

Номера переменных можно использовать для обращения к ним в теле функции,
но поскольку это может быть неудобно, переменной можно дать символьное
название, используя символ доллара. В примере выше переменная с номером
1 имеет название `a`, а переменная с номером 2 названа `b`.

Команды Wasm оперируют над абстрактным стеком. Во время исполнения
значения помещаются на стек и извлекаются со стека различными командами.

Функция сложения двух целых чисел представима в текстовом формате Wasm
следующим образом:

```
(module
  (func $add (param $a i32) (param $b i32) (result i32)
    local.get $a
    local.get $b
    i32.add
  )
)
```

Команды в функции `add` (так же как с локальными переменными название функции можно
указать после знака доллара) делают следующее:
1. `local.get $a` помещает значение параметра `a` на стек;
2. `local.get $b` помещает значение параметра `b` на стек;
3. `i32.add` снимает 2 значения со стека, выполняет операцию сложения и
помещает результат на стек.

Эту же функцию можно переписать, используя S-выражения до самого конца:

```
(module
  (func $add (param $a i32) (param $b i32) (result i32)
    (i32.add
      (local.get $a)
      (local.get $b)
    )
  )
)
```

Данный компилятор использует списки команд вместо S-выражений везде,
где это применимо.

Помимо примитивных команд, WebAssembly предоставляет конструкции для описания
ветвления и циклов.

Ветвление описывается с помощью конструкции `if`.

```
(if
  (<S-выражение для условия>)
  (then <список команд или S-выражение, если условие выполняется>)
  (else <список команд или S-выражение, если условие не выполняется>)
)
```

Выражения для условия и `else` не являются обязательными.
В случае, если S-выражение для условия не указано, то со стека снимается
значение, которое используется в качестве условия.

Для описания циклов в текстовом описании WebAssembly существует
конструкция `loop`. Она может использоваться совместно с конструкцией
`block` и командами `br_if` и `br` для описания различных видов циклов.

Пример кода, сгенерированного для цикла `for`:
```
...

local.get $r0
i32.const 0
local.set $ix
i32.const 10
local.set $r0
(block $end
  (loop $continue
    local.get $r0
    local.get $ix
    i32.eq
    br_if $end
    local.get $ix
    call $writeln_int
    i32.const 1
    local.get $ix
    i32.add
    local.set $ix
    br $continue
  )
)

...
```

Блокам `block` и `loop` по умолчанию присваиваются номера, которые можно
использовать в командах перехода `br` и `br_if`, но аналогично параметрам
и названиям функций для читаемости можно использовать символьные имена,
указанные со знаком доллара.

### Импорты и экспорты

Одной из важных возможностей WebAssembly является взаимодействие с окружением.
Это допускается посредством импортов и экспортов.

В основном это касается функций. Вот так можно экспортировать функцию

```
(module
  (func $add ... )
  (export "add" (func $add))
)
```

или более кратко

```
(module
  (func (export "add") ... )
)
```

При втором варианте экспортирования к функции `add` WebAssembly
всё ещё можно обращаться по её имени.

Аналогично работают импорты

```
(module
  (func $writeln_int (import "imports" "writeln_int") (param i32))
)
```

В примере выше ожидается, что окружение при создании экземпляра
модуля передаст объект `imports`, содержащий функцию `writeln_int`.

Импортированную функцию (как и любую другую функцию) внутри WebAssembly
можно вызвать следующим образом

```
call $writeln_int
```

Для этого вызова со стека будут снято количество значений, равное количеству
аргументов функции, указанном в её описании.

WebAssembly имеет множество других возможностей, которые не используются
в данном компиляторе. Наиболее полное их описание можно найти в
[спецификации](https://webassembly.github.io/spec/core/).

## Wasm в коде компилятора

Обязанность по генерации конкретных команд в текстовом представлении
WebAssembly 
Структура, реализующая генерацию кода отдельных команд WebAssembly называется
`Wasm`.

```rust
pub struct Wasm {
    output: Output,
    silenced: bool,
}
```

Методы этой структуры выводят команды WebAssembly в предоставленный структуре
`Wasm` объект `Output`. Часть методов формирует команды целиком. Для команд,
который могут содержать команды внутри себя, методы генерации разбиты на пары
`<команда>_start`, `<команда>_end`.

## Запуск сгенерированного кода

Сгенерированный код можно запустить в любом окружении, поддерживающем
WebAssembly. В данной репозитории имеется [скрипт](../../scripts/wun.ts) для Deno,
среды исполнения JavaScript и TypeScript, который запускает .wasm файл в папке
[tests/data/output](tests/data/output).

## Тестирование
Тесты, с помощью которых проверялась корректность генерации кода, находятся
в папке [tests/data/correct](../../tests/data/correct)
