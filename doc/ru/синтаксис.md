# Разбор синтаксиса

В реализованном компиляторе разбор синтаксиса является точкой входа.
Семантический анализ и генерация кода происходят одновременно
с разбором синтаксиса исходного кода внутри методов, реализующих
разбор правил БНФ.

Базовый набор правил был взят
[отсюда](https://condor.depaul.edu/ichu/csc447/notes/wk2/pascal.html),
но часть правил не реализована, а другая часть реализована с некоторыми
изменениями.
А именно 
1. были убраны правила связанные с разбором функций и процедур,
вариативной частью в записях, массивы, операторы switch и goto,
файлы, указатели, множества;
2. правила разбора переменной были изменены для упрощения семантического
анализа.

## Структура `Code`

Синтаксический анализ (и по факту весь компилятор) представлен структурой
`Code`.

```rust
pub struct Code<T: Buffer> {
    token_stream: TokenStream<T>,
    lookahead: Token,
    scope: Box<Scope>,
    errors: Errors,
    wasm: WASM,
}
```

Структура `Code` предоставляет публичные методы для компиляции исходного кода
и для его отдельной проверки.

```rust
    impl<T: Buffer> Code<T>  {
        ...

        pub fn compile(mut self) -> Result<Errors, CompilationError> {
            ...
        }
    
        pub fn check(mut self) -> Result<Errors, CompilationError> {
            ...
        }

        ...
    }

```

Для создания структуры `Code` требуется экземпляр структуры `TokenStream`,
а также объект, реализующий типаж `Write`, для вывода сгенерированного кода.

```rust
    pub fn new(
        token_stream: TokenStream<T>,
        output: Box<dyn Write>
    ) -> Code<T>
```

## Нейтрализация ошибок

Реализованный компилятор имеет базовую возможность восстанавливаться
после некоторых синтаксических ошибок и продолжать разбор синтаксиса
до конца файла.

Подход к восстановлению ошибок, используемый в данном компиляторе, -- пропуск
до синхронизирующего символа. Для поддержки этого подхода был реализован
метод `panic` у структуры `Code`.

```rust
fn panic(&mut self, until_tokens: &[Token]) -> ParseResult
```

Метод `panic` принимает на вход список синхронизирующих токенов `until_tokens`,
узнаёт у объекта `TokenStream`, есть ли дальше в потоке токенов
какой-нибудь токен из указанных в списке `until_tokens`. Если так,
то происходит синхронизация до ближайшего такого токена. После чего разбор
синтаксиса продолжается с правила в иерархии правил, которое будет обязательно
выше правила, в котором произошла ошибка.

## Тестирование

Тесты разбора синтаксиса описаны в конце файла
[code.rs](../../src/parsing/code.rs).
