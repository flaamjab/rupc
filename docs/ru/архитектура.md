# Архитектура компилятора

Rudimentary Pascal Compiler является однопроходным компилятором,
состоящим из набора модулей, которые напрямую соответствуют
основным задачам, выполняющимся компилятором во время работы.

# Токенизация

Токенизатор представляет собой конечный автомат. В качестве входных
данных он принимает последовательность ASCII символов и преобразовывает её
в последовательность токенов языка Pascal.

Токены для упрощения последующих этапов сгруппированы
по смыслу в следующие группы:
1. операторы,
2. отношения сравнения,
3. ключевые слова,
4. пунктуация,
5. литералы,
6. идентификаторы.

Токены, которые распознаются токенизатором (каждой последовательности
литер соответствует один токен):
| Последовательность литер                                                               | Группа токенов |
| -------------------------------------------------------------------------------------- | -------------- |
| «+», «-», «*», div, mod, or, not                                                       | Op             |
| «=», «<», «<=», «<>», «>», «>=»                                                        | Rel            |
| true, false, if, then, else, of, while, do, begin, end, var, array, procedure, program | Keyword        |
| «[», «]», «(», «)», «.», «,», «;», «..»                                                | Punctuation    |
| `'[^']*'`                                                                              | Literal        |
| `[_a-zA-Z]([_a-zA-Z]\|[0-9])*`                                                         | Id             |
| `[0-9]+(.[0-9])?([Ee][+-]?[0-9]+)?`                                                    | Number         |

Детали токенизации описаны [здесь](токенизация.md)

# Разбор синтаксиса

В качестве основы для грамматики, поддерживаемой компилятором, были
использованы БНФ-правила, перечисленные
[здесь](https://condor.depaul.edu/ichu/csc447/notes/wk2/pascal.html).

Детали разбора синтаксиса описаны [здесь](синтаксис.md).

# Семантический анализ

Семантический анализ проводится внутри функций,
реализующих разбор синтаксиса.

Детали семантического анализа описаны [здесь](семантика.md).

# Генерация кода

Код генерируется в текстовое представление WebAssembly, а затем
трансформируются в двоичное представления с использованием
небольшой библиотеки [wat](https://crates.io/crates/wat).

Аналогично семантическому анализу, функции генерации кода запускаются
внутри функций разбора синтаксиса. Но в отличие от семантического анализа,
непосредственная реализация генерации кода находится в своём собственном модуле.

Генератор кода поддерживает только числовые типы данных
и арифметические операции над ними.

Для вывода результата программы, используется переменная `result`.

Детали генерации кода описаны [здесь](генерация.md)
